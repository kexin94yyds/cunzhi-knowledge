## 07:37:59  @ cunzhi

### 🤖 AI
## 已推送到 GitHub

✅ **cunzhi-knowledge 仓库已更新**

### 完成内容
- `skills/ralph-loop/SKILL.md` - Ralph Wiggum 自主循环模式
- `skills/INDEX.md` - 添加索引

### 触发方式
```
ralph: 执行以下任务直到完成
1. 任务1
2. 任务2
```

还有其他需求吗？

### 👤 用户
上传到 github

✔️不明白的地方反问我，先不着急编码
询问是否记录到 .cunzhi-knowledge/problems.md
继续调用 zhi
✔git保存

---
## 07:42:25  @ cunzhi

### 🤖 AI
## Debug Skill 已增强

✅ **已更新并推送到 GitHub**

### 新增内容

**三阶段调试法**：

| 阶段 | 内容 | 关键点 |
|------|------|--------|
| **第一阶段** | 精准定位 | 收集 5 项信息（复现步骤、当前表现、预期表现、错误信息、环境信息） |
| **第二阶段** | 辅助排查 | 植入 Debug Log → 分析日志 → 定位根源 |
| **第三阶段** | 清洗代码 | 总结 → 回退 → 重新开始（防止质量劣化） |

### 核心原则

1. **必须按流程执行**：不能跳过任何阶段
2. **不确定时反问**：宁可多问，不能瞎猜
3. **每步都要汇报**：调用 zhi 让用户确认

### 还有其他需求吗？

### 👤 用户
III. 有效地 Debug
    如果 AI 还是会写出 bug，我们需要让 AI 帮我们 debug。
    第一阶段：精准定位 (向 AI 提供核心信息)
        1. 准确描述 Bug
            1. 复现步骤 (Steps to Reproduce)：
                ◦ 详细说明如何一步步触发 Bug。
                ◦ 示例：明确指出在“哪个页面”点击了“哪个按钮”。
            2. 当前表现 (Current Behavior)：
                ◦ 描述 Bug 发生时 App 的具体反应。
                ◦ 示例：点击按钮后“没有任何反应”。
            3. 预期表现 (Expected Behavior)：
                ◦ 说明你期望程序应该发生什么。
                ◦ 示例：点击后应该“跳转到另一个页面”。
            4. 错误信息 (Error Messages)：
                ◦ 提供任何可见的报错。
                ◦ 技巧：对于 Web App，打开浏览器的开发者工具（Console 控制台），通常能看到隐藏的错误信息。
            5. 环境信息 (Environment Details)：
                ◦ 补充运行环境的细节。
                ◦ 示例：说明是在“手机”还是“特定浏览器”中运行。
    第二阶段：辅助排查 (当 AI 找不到原因时)
        2. 使用 Debug Log
            如果 AI 还是找不到问题所在，可以要求 AI 在它觉得有可能犯错误的地方加上详细的 debug log，然后让 AI 自己去读它 log 出来的东西。这样 AI 就能看到它执行步骤中的具体细节，从而更好地找到问题。
            • 植入调试日志 (Debug Logging)：让 AI 在它认为可能出错的代码段中加入详细的 Debug Log。
            • 分析执行细节：让 AI 自己读取输出的日志。这样它能看到代码执行的具体流程和变量状态，从而锁定问题根源。
            Debug提示词
                1. 🔍 植入详细调试日志 (Debug Logging)
                    请在您认为最有可能导致错误的重点代码段中，要求或模拟添加详细的 Debug Log（或 print 语句）。
                    目的： 收集执行到该位置时，程序内部的关键信息和数据流。
                2. 📝 自主分析日志细节
                    在获取到新的日志输出后，请您自主读取、分析并解释这些日志，而不是仅仅简单列出它们。
                    分析重点：
                    代码执行的具体流程： 跟踪代码实际的运行路径。
                    关键变量状态： 特别关注变量（如输入参数、循环计数器、条件判断结果等）在执行前后的具体数值和状态。
                3. 💡 定位并确认根源
                    利用 Debug Log 中提供的微观细节，明确指出：
                    哪个具体的代码行或逻辑块是错误的根源。
                    为什么该行代码/逻辑块会导致错误（基于变量状态或流程跳转的异常）。
    第三阶段：清洗代码 (防止代码质量劣化)
        3. 处理重复修改导致的质量下降
        如果 AI 一次修改不对，它反复修改往往会导致代码质量下降。此时的最佳做法是
            1. 让 AI 在修复完问题之后总结它找到的问题根源以及它是怎么修改的。
            2. 将这个总结保存下来，让 AI 回退它之前的所有修改，回到最初始的状态。
            3. 开启一个新的对话，直接把这个问题以及刚才保存下来的问题根源和修改方法再给 AI 一次，让它一次性改对。
            4. 这时它修改代码的质量一般会好很多。
                这些方法（从上下文工程到主动测试、代码审查 Agent 以及与 AI 有效交流来进行 debug）都是驾驭 AI 进行高效开发的必修课。
        代码嵌套
            在这个问题上我们已经修改多次，仍然没有效果，我怀疑是因为该部分的代码因为多次迭代导致了结构复杂，产生了不必要的嵌套，导致你的更新无法生效。我建议你完全删除这部分的逻辑，根据我们讨论的实际需求重新写代码，这样可以避免你的更新被原有逻辑影响
    当然还有一个意外
        就是你的操作根本和你的后台无关，所以后台才会没有反应

我希望我们的 Skills 关于 debug 的部分，即便它不会处理，也可以反问我。

因为我们的 debug 步骤已经非常清晰了，你可以看一看，它完全可以按照这个流程去走一走。

✔️不明白的地方反问我，先不着急编码
询问是否记录到 .cunzhi-knowledge/problems.md
继续调用 zhi
✔git保存

---
## 07:44:17  @ cunzhi

### 🤖 AI
## Ralph 模式 vs Debug Skill 的区别

### 核心区别

| 维度 | Ralph 模式 | Debug Skill |
|------|-----------|-------------|
| **适用场景** | 明确的任务清单 | 不确定的问题排查 |
| **用户介入** | 全部完成后才通知 | 每步都要确认 |
| **自动化程度** | 高（有测试验证） | 低（需要人工判断） |
| **风险等级** | 低（可回滚） | 高（可能越改越乱） |

### 什么时候用 Ralph？

```
ralph: 修复这3个Bug
1. P-001 - 有明确的复现步骤和测试
2. P-002 - 有明确的复现步骤和测试
3. P-003 - 有明确的复现步骤和测试
```

**前提条件**：
- ✅ 问题已经定位清楚
- ✅ 有自动化测试验证
- ✅ 任务之间相对独立

### 什么时候用 Debug Skill？

```
用户：这个按钮点了没反应
```

**特点**：
- ❌ 问题还没定位
- ❌ 不确定是前端还是后端
- ❌ 需要收集更多信息

### 两者的配合

```
1. 用户报告 Bug
      ↓
2. 进入 Debug Skill（每步汇报）
      ↓
3. 定位到问题根源
      ↓
4. 如果有多个类似问题，切换到 Ralph 模式批量修复
```

### 简单说

- **Debug = 侦探模式**：不确定凶手是谁，需要一步步排查，每步都要和用户确认
- **Ralph = 执行模式**：已经知道要做什么，自动执行直到完成

### 需要我更新文档说明这个区别吗？

### 👤 用户
那我们每一步都要多问、每一步都要汇报的话，和那个 Ruff 之间是不是就有点矛盾了？

比如说，如果我已经让他用过 Ruff 了，那这两者之间有什么区别呢？

✔️不明白的地方反问我，先不着急编码
询问是否记录到 .cunzhi-knowledge/problems.md
继续调用 zhi
✔git保存

---
